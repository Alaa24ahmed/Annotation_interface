<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multicultural Reasoning Benchmark - Annotation Tool</title>
    
    <!-- Add FingerprintJS -->
    <script src="https://cdn.jsdelivr.net/npm/@fingerprintjs/fingerprintjs@3/dist/fp.min.js"></script>
    
    <style>
        :root {
          --primary-color: #4361ee;
          --primary-light: #4895ef;
          --primary-dark: #3f37c9;
          --accent-color: #f72585;
          --success-color: #4cc9f0;
          --warning-color: #f8961e;
          --error-color: #e63946;
          --text-dark: #2b2d42;
          --text-light: #8d99ae;
          --background-light: #f8f9fa;
          --background-card: #ffffff;
          --border-color: #e5e7eb;
        }

        body {
          font-family: 'Segoe UI', Roboto, -apple-system, BlinkMacSystemFont, Oxygen, Ubuntu, sans-serif;
          line-height: 1.7;
          max-width: 1300px;
          margin: 0 auto;
          padding: 20px;
          color: var(--text-dark);
          background-color: var(--background-light);
        }

        h1, h2, h3 {
          font-weight: 600;
          color: var(--primary-dark);
          letter-spacing: -0.01em;
        }

        h1 {
          font-size: 1.8rem;
          margin-bottom: 1.5rem;
          text-align: center;
        }

        h2 {
          font-size: 1.4rem;
          margin-top: 2rem;
          border-bottom: 2px solid var(--primary-light);
          padding-bottom: 0.5rem;
        }

        h3 {
          font-size: 1.1rem;
          margin-bottom: 0.8rem;
        }

        .template {
          margin-bottom: 30px;
          padding: 25px;
          border-radius: 10px;
          background-color: var(--background-card);
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
          transition: box-shadow 0.3s ease;
        }

        .placeholder {
          background-color: rgba(67, 97, 238, 0.1);
          padding: 3px 8px;
          border-radius: 5px;
          cursor: pointer;
          border: 1px dashed var(--primary-color);
          transition: all 0.2s ease;
          display: inline-block;
          margin: 3px 2px;
        }

        .placeholder:hover {
          background-color: rgba(67, 97, 238, 0.2);
          transform: translateY(-2px);
          box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }

        input[type="text"] {
          padding: 8px 12px;
          border: 2px solid var(--primary-light);
          border-radius: 6px;
          font-size: inherit;
          width: 200px;
          transition: all 0.2s ease;
          box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        input[type="text"]:focus {
          border-color: var(--primary-color);
          box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.25);
          outline: none;
        }

        .actions {
          display: flex;
          gap: 15px;
          margin-top: 25px;
        }

        button {
          padding: 10px 20px;
          background-color: var(--primary-color);
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-weight: 500;
          font-size: 1rem;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 2px 6px rgba(0,0,0,0.1);
          position: relative;
        }

        button:hover {
          background-color: var(--primary-dark);
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        button:active {
          transform: translateY(0);
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:disabled {
          background-color: var(--text-light);
          color: rgba(255,255,255,0.8);
          cursor: not-allowed;
          transform: none;
          box-shadow: none;
        }

        #reset-btn {
          background-color: #6c757d;
        }

        #reset-btn:hover {
          background-color: #5a6268;
        }

        /* Tooltip for disabled button */
        button:disabled:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            white-space: normal;
            text-align: center;
            z-index: 10;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: normal;
            min-width: 200px;
            max-width: 300px;
            width: max-content;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            line-height: 1.4;
            word-wrap: break-word;
        }

        /* Arrow for tooltip */
        button:disabled:hover::before {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
            margin-bottom: 2px;
        }

        /* Not applicable button styling */
        #not-applicable-btn {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            position: relative;
        }

        #not-applicable-btn:hover {
            background-color: #ffeaa7;
            color: #6c5400;
            border-color: #ffd93d;
        }

        #not-applicable-btn::before {
            content: "‚ö†Ô∏è";
            margin-right: 8px;
        }

        /* Skip Reason Modal */
        .skip-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .skip-modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .skip-modal h3 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .skip-modal p {
            color: #666;
            margin-bottom: 20px;
        }
        
        .skip-reason-input {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 20px;
            box-sizing: border-box;
        }
        
        .skip-reason-input:focus {
            outline: none;
            border-color: #ffd60a;
            box-shadow: 0 0 0 3px rgba(255, 214, 10, 0.1);
        }
        
        .skip-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .skip-modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .skip-cancel-btn {
            background-color: #6c757d;
            color: white;
        }
        
        .skip-cancel-btn:hover {
            background-color: #5a6268;
        }
        
        .skip-confirm-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .skip-confirm-btn:hover {
            background-color: #c0392b;
        }
        
        .skip-confirm-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        textarea {
          width: 100%;
          min-height: 80px;
          padding: 12px;
          border: 2px solid var(--border-color);
          border-radius: 6px;
          font-family: inherit;
          font-size: inherit;
          resize: vertical;
          transition: all 0.2s ease;
          box-sizing: border-box;
        }

        textarea:focus {
          border-color: var(--primary-color);
          box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.25);
          outline: none;
        }

        .status {
          margin-top: 20px;
          padding: 15px;
          border-radius: 6px;
          display: none;
          font-weight: 500;
          animation: fadeIn 0.3s ease;
        }

        .success {
          display: block;
          background-color: rgba(76, 201, 240, 0.15);
          color: #0077b6;
          border-left: 4px solid #0077b6;
        }

        .error {
          display: block;
          background-color: rgba(230, 57, 70, 0.15);
          color: #d62828;
          border-left: 4px solid #d62828;
        }

        .template-info {
            margin-bottom: 15px;
            font-size: 0.9em;
            color: var(--text-light);
            font-style: italic;
        }

        .loading {
          text-align: center;
          padding: 40px 20px;
          font-style: italic;
          color: var(--text-light);
          background-color: var(--background-card);
          border-radius: 10px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
          animation: pulse 1.5s infinite ease-in-out;
        }

        .preview-panel {
          margin-top: 25px;
          padding: 20px;
          border: 1px solid var(--border-color);
          border-radius: 8px;
          background-color: var(--background-light);
          display: none;
          animation: slideIn 0.3s ease;
          box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .preview-content {
            margin-bottom: 15px;
        }

        .preview-question {
          padding: 15px;
          background-color: white;
          border: 1px solid var(--border-color);
          border-radius: 6px;
          margin: 10px 0 20px;
        }

        .preview-actions {
            display: flex;
            gap: 10px;
        }

        #confirm-submit {
            background-color: var(--success-color);
        }

        #cancel-preview {
            background-color: var(--error-color);
        }

        /* True-False Preview Styles */
        .true-false-preview {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .true-false-item {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: #f8f9fa;
        }

        .true-false-item p {
            margin: 0 0 8px 0;
            font-weight: 600;
            color: var(--text-dark);
        }

        .statement-content {
            padding: 12px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .statement-content.translation {
            background-color: #f0f8ff;
            border-left: 4px solid var(--primary-color);
        }

        .progress-container {
          margin: 30px auto;
          max-width: 600px;
        }

        .progress-steps {
          display: flex;
          justify-content: space-between;
          position: relative;
        }

        .progress-steps::before {
          content: '';
          position: absolute;
          top: 15px;
          left: 0;
          right: 0;
          height: 2px;
          background: var(--border-color);
          z-index: 0;
        }

        .step {
          position: relative;
          z-index: 1;
          display: flex;
          flex-direction: column;
          align-items: center;
          flex: 1;
        }

        .step-number {
          width: 30px;
          height: 30px;
          border-radius: 50%;
          background: var(--text-light);
          color: white;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: bold;
          margin-bottom: 6px;
        }

        .step.active .step-number {
          background: var(--primary-color);
        }

        .step-label {
          font-size: 0.85rem;
          color: var(--text-light);
        }

        .step.active .step-label {
          color: var(--primary-color);
          font-weight: 500;
        }

        /* Cultural authenticity instruction banner */
        .cultural-instruction {
            margin: 25px 0;
            padding: 15px 20px;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            border-radius: 8px;
            color: #856404;
            font-weight: 600;
            text-align: center;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }
        
        .cultural-instruction::before {
            content: "üéØ";
            font-size: 1.2em;
            margin-right: 8px;
        }
        
        .cultural-instruction strong {
            color: #664d03;
        }

        /* New styles for options */
        .options-container {
            margin-top: 15px;
        }
        
        .option-item {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
        }
        
        .option-label {
            font-weight: bold;
            margin-right: 10px;
            min-width: 25px;
            padding-top: 8px;
        }
        
        .option-content {
            flex: 1;
            background-color: var(--background-light);
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-light);
        }
        
        .correct-option {
            background-color: rgba(76, 201, 240, 0.1);
            border-radius: 6px;
            padding: 5px;
        }
        
        .correct-option .option-content {
            border-left-color: var(--success-color);
        }
        
        .correct-marker {
            font-size: 0.8rem;
            color: var(--success-color);
            font-weight: 500;
            margin-left: 10px;
            font-style: italic;
        }
        
        /* Fieldset styling */
        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: var(--background-card);
        }
        
        legend {
            font-weight: 600;
            padding: 0 10px;
            color: var(--primary-color);
        }
        /* Smaller translation textareas */
        #translation-question {
            min-height: 60px;
            max-height: 120px;
            height: auto;
        }

        /* Translation option textareas */
        #translation-option-a,
        #translation-option-b, 
        #translation-option-c,
        #translation-option-d {
            min-height: 40px;
            max-height: 80px;
            height: auto;
            padding: 8px;
        }

        /* Improve spacing in option content */
        .option-content {
            padding: 8px;
        }

        .option-content textarea {
            margin: 0;
            width: 100%;
            box-sizing: border-box;
        }

        /* Add resize handle indicator */
        textarea {
            resize: vertical;
            background-image: linear-gradient(45deg, transparent 90%, rgba(0,0,0,0.1) 90%), 
                            linear-gradient(-45deg, transparent 90%, rgba(0,0,0,0.1) 90%);
            background-position: right bottom;
            background-repeat: no-repeat;
            background-size: 12px 12px;
            background-origin: content-box;
        }

        /* Example question styling */
        .example-fieldset {
            background-color: rgba(242, 247, 255, 0.8);
            border: 1px dashed var(--primary-light);
        }

        .example-fieldset legend {
            color: var(--primary-dark);
            background-color: rgba(242, 247, 255, 0.8);
        }

        .example-container {
            padding: 0 5px;
        }

        #example-title {
            font-style: italic;
            font-weight: normal;
            color: var(--text-light);
            margin-top: 0;
            font-size: 0.9rem;
        }

        .example-question-container, .example-options-container {
            margin-bottom: 15px;
        }

        .example-question {
            background-color: white;
            padding: 10px 15px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
        }

        .example-options-container .options-container {
            margin-top: 10px;
        }

        .example-options-container .option-content {
            font-size: 0.95rem;
        }

        /* Simple directions panel styling */
        .directions-panel {
            background-color: #f0f8ff;
            border-radius: 8px;
            padding: 10px 15px;
            margin-bottom: 20px;
            border-left: 3px solid var(--primary-color);
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .directions-panel h3 {
            margin: 0;
            color: var(--primary-dark);
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .toggle-directions {
            font-size: 0.9rem;
            color: var(--primary-color);
            background-color: rgba(67, 97, 238, 0.1);
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .directions-content {
            margin-top: 8px;
            overflow: hidden;
        }

        /* Simple ordered list styling */
        .directions-list {
            margin: 0;
            padding-left: 25px;
        }

        .directions-list li {
            margin-bottom: 6px;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .directions-list li:last-child {
            margin-bottom: 0;
        }

        .directions-list li strong {
            color: var(--primary-dark);
        }

        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }

        @keyframes slideIn {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }
        
        /* Side-by-side layout styles */
        .side-by-side-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }
        
        .english-column,
        .translation-column {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background-color: var(--background-card);
        }
        
        .english-column h3,
        .translation-column h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 1.1rem;
            border-bottom: 2px solid var(--primary-light);
            padding-bottom: 5px;
        }
        
        .question-section,
        .options-section {
            margin-bottom: 20px;
        }
        
        .question-section h4,
        .options-section h4 {
            margin: 0 0 10px 0;
            color: var(--text-dark);
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        .question-display {
            background-color: var(--background-light);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
            min-height: 50px;
            font-style: italic;
            color: var(--text-light);
        }
        
        .question-display.filled {
            background-color: white;
            color: var(--text-dark);
            font-style: normal;
            border-left: 3px solid var(--success-color);
        }
        
        .option-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: var(--background-light);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .option-display.correct-option {
            background-color: rgba(76, 201, 240, 0.1);
            border-color: var(--success-color);
        }
        
        .option-display .option-label {
            font-weight: 600;
            color: var(--primary-color);
            min-width: 20px;
        }
        
        .option-display .option-text {
            flex: 1;
            color: var(--text-light);
            font-style: italic;
        }
        
        .option-display .option-text.filled {
            color: var(--text-dark);
            font-style: normal;
        }
        
        .correct-badge {
            background-color: var(--success-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .translation-option {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 12px;
            padding: 8px;
            border-radius: 6px;
            background-color: var(--background-light);
        }
        
        .translation-option.correct-option {
            background-color: rgba(76, 201, 240, 0.1);
        }
        
        .translation-option .option-label {
            font-weight: 600;
            color: var(--primary-color);
            min-width: 20px;
            margin-top: 8px;
        }
        
        .translation-option textarea {
            flex: 1;
            min-height: 40px;
            max-height: 80px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .translation-option .correct-badge {
            margin-top: 8px;
        }
        
        /* True-False Questions Section - Exact match to Question & Translation styling */
        .true-false-section {
            margin-bottom: 20px;
        }
        
        .true-false-section h4 {
            margin: 0 0 10px 0;
            color: var(--text-dark);
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        .statement-display {
            background-color: var(--background-light);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--primary-color);
            min-height: 50px;
            font-style: italic;
            color: var(--text-light);
            line-height: 1.5;
            display: flex;
            align-items: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .statement-display.filled {
            background-color: white;
            color: var(--text-dark);
            font-style: normal;
            border-left: 3px solid var(--success-color);
        }
        
        .true-false-section textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .true-false-section textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.2);
        }
        
        /* Responsive design for mobile */
        @media (max-width: 768px) {
            .side-by-side-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
        
        /* Interactive template content styles */
        .template-content {
            background-color: var(--background-light);
            padding: 12px;
            border-radius: 6px;
            border: 2px dashed var(--primary-light);
            min-height: 50px;
            line-height: 1.6;
        }
        
        .option-content-interactive {
            background-color: var(--background-light);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px dashed var(--border-color);
            min-height: 30px;
            flex: 1;
            line-height: 1.5;
        }
        
        /* Progress indicator for subset mode */
        .progress-indicator {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(67, 97, 238, 0.2);
        }
        
        /* Completion message for subset mode */
        .completion-message {
            text-align: center;
            padding: 40px;
            background-color: var(--background-card);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            margin: 0 auto;
        }
        
        .completion-message h2 {
            color: var(--success-color);
            margin-bottom: 20px;
            font-size: 2rem;
        }
        
        .completion-message p {
            color: var(--text-dark);
            margin-bottom: 15px;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .completion-stats {
            background-color: var(--background-light);
            padding: 20px;
            border-radius: 8px;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .completion-stats div {
            font-weight: 600;
            color: var(--text-dark);
            padding: 8px 0;
        }
        
        /* Progress indicator styles */
        .progress-indicator {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-weight: 600;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(67, 97, 238, 0.3);
        }
        
        /* Completion message styles */
        .completion-message {
            text-align: center;
            padding: 40px;
            background-color: var(--background-card);
            border-radius: 15px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            margin: 20px;
        }
        
        .completion-message h2 {
            color: var(--success-color);
            margin-bottom: 20px;
            font-size: 2.2rem;
        }
        
        .completion-message p {
            color: var(--text-dark);
            font-size: 1.1rem;
            margin-bottom: 15px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>Multicultural Reasoning Benchmark Annotation Tool</h1>
    
    <div class="progress-container">
      <div class="progress-steps">
        <div class="step active">
          <div class="step-number">1</div>
          <div class="step-label">Fill Template</div>
        </div>
        <div class="step">
          <div class="step-number">2</div>
          <div class="step-label">Translate</div>
        </div>
        <div class="step">
          <div class="step-number">3</div>
          <div class="step-label">Submit</div>
        </div>
      </div>
    </div>
    
    <div id="loading" class="loading">
        Loading template...
    </div>
    
    <div class="template" id="template-container" style="display: none;">
        <!-- Simple Numbered List Directions Panel -->
        <div class="directions-panel">
            <h3>Steps to Complete <span class="toggle-directions" title="Click to expand/collapse">[?]</span></h3>
            <div class="directions-content">
                <ol class="directions-list">
                    <li><strong>Examine</strong> template format and example completed question.</li>
                    <li><strong>Fill placeholders</strong> with authentic content from your culture (in English). Use search engines to fact-check details.</li>
                    <li><strong>Translate</strong> the complete question and the true-false variations to your native language (and dialect if applicable).</li>
                    <li><strong>Review</strong> for accuracy and authenticity, then submit.</li>
                </ol>
            </div>
        </div>
        
        <!-- Cultural Authenticity Instruction -->
        <div class="cultural-instruction">
            <strong>Use Local Values Only:</strong> Replace all placeholders with authentic examples from your own culture and region. This ensures genuine cultural representation.
        </div>
        
        <h2>Question Template</h2>
        
        <!-- Question Template -->
        <fieldset>
            <legend>Question</legend>
            <p id="template-text"></p>
            <div id="template-note" style="display: none; margin-top: 10px; padding: 10px; background-color: #f0f8ff; border-left: 4px solid #007bff; font-style: italic;">
                <strong>Note:</strong> <span id="template-note-text"></span>
            </div>
        </fieldset>
        
        <!-- Options Template -->
        <fieldset>
            <legend>Options</legend>
            <div class="options-container">
                <div class="option-item correct-option">
                    <div class="option-label">A.</div>
                    <div class="option-content" id="option-a-template"></div>
                    <div class="correct-marker">Correct Answer</div>
                </div>
                <div class="option-item">
                    <div class="option-label">B.</div>
                    <div class="option-content" id="option-b-template"></div>
                </div>
                <div class="option-item">
                    <div class="option-label">C.</div>
                    <div class="option-content" id="option-c-template"></div>
                </div>
                <div class="option-item">
                    <div class="option-label">D.</div>
                    <div class="option-content" id="option-d-template"></div>
                </div>
            </div>
        </fieldset>

        <!-- Example Question (Collapsible) -->
        <div class="directions-panel">
            <h3>Example Completed Question <span class="toggle-example" title="Click to expand/collapse">[‚àí]</span></h3>
            <div class="example-content">
                <h4 id="example-title">Here's how this question might look when completed:</h4>
                <div class="example-question-container">
                    <p><strong>Question:</strong></p>
                    <div class="example-question" id="example-question">Which of the following is the furthest from Jakarta?</div>
                </div>
                
                <div class="example-options-container">
                    <p><strong>Options:</strong></p>
                    <div class="options-container">
                        <div class="option-item correct-option">
                            <div class="option-label">A.</div>
                            <div class="option-content" id="example-option-a">London (correct - 11,716 km)</div>
                            <div class="correct-marker">Correct Answer</div>
                        </div>
                        <div class="option-item">
                            <div class="option-label">B.</div>
                            <div class="option-content" id="example-option-b">Manila (2,294 km)</div>
                        </div>
                        <div class="option-item">
                            <div class="option-label">C.</div>
                            <div class="option-content" id="example-option-c">Bangkok (2,361 km)</div>
                        </div>
                        <div class="option-item">
                            <div class="option-label">D.</div>
                            <div class="option-content" id="example-option-d">Singapore (884 km)</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Side-by-Side English & Translation -->
        <fieldset>
            <legend>Question & Translation</legend>
            <div class="side-by-side-container">
                <!-- English Column (Auto-updated) -->
                <div class="english-column">
                    <h3>English Version</h3>
                    <div class="english-content">
                        <div class="question-section">
                            <h4>Question:</h4>
                            <div class="question-display" id="english-question-display">Complete the template above to see your question here</div>
                        </div>
                        <div class="options-section">
                            <h4>Options:</h4>
                            <div class="option-display correct-option">
                                <span class="option-label">A.</span>
                                <span class="option-text" id="english-option-a">Fill template to see option A</span>
                                <span class="correct-badge">Correct</span>
                            </div>
                            <div class="option-display">
                                <span class="option-label">B.</span>
                                <span class="option-text" id="english-option-b">Fill template to see option B</span>
                            </div>
                            <div class="option-display">
                                <span class="option-label">C.</span>
                                <span class="option-text" id="english-option-c">Fill template to see option C</span>
                            </div>
                            <div class="option-display">
                                <span class="option-label">D.</span>
                                <span class="option-text" id="english-option-d">Fill template to see option D</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Translation Column -->
                <div class="translation-column">
                    <h3>Your Language Translation</h3>
                    <div class="translation-content">
                        <div class="question-section">
                            <h4>Question Translation:</h4>
                            <textarea id="translation-question" placeholder="Translate the question into your language..."></textarea>
                        </div>
                        <div class="options-section">
                            <h4>Options Translation:</h4>
                            <div class="translation-option correct-option">
                                <span class="option-label">A.</span>
                                <textarea id="translation-option-a" placeholder="Translate option A..."></textarea>
                                <span class="correct-badge">Correct</span>
                            </div>
                            <div class="translation-option">
                                <span class="option-label">B.</span>
                                <textarea id="translation-option-b" placeholder="Translate option B..."></textarea>
                            </div>
                            <div class="translation-option">
                                <span class="option-label">C.</span>
                                <textarea id="translation-option-c" placeholder="Translate option C..."></textarea>
                            </div>
                            <div class="translation-option">
                                <span class="option-label">D.</span>
                                <textarea id="translation-option-d" placeholder="Translate option D..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </fieldset>

        <!-- True-False Questions & Translation -->
        <fieldset>
            <legend>True-False Questions & Translation</legend>
            <div class="side-by-side-container">
                <!-- English Column -->
                <div class="english-column">
                    <h3>English Version</h3>
                    <div class="english-content">
                        <div class="true-false-section">
                            <h4>TRUE Statement:</h4>
                            <div class="statement-display" id="true-statement-english">
                                Complete the template above to see the TRUE statement here
                            </div>
                        </div>
                        <div class="true-false-section">
                            <h4>FALSE Statement:</h4>
                            <div class="statement-display" id="false-statement-english">
                                Complete the template above to see the FALSE statement here
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Translation Column -->
                <div class="translation-column">
                    <h3>Your Language Translation</h3>
                    <div class="translation-content">
                        <div class="true-false-section">
                            <h4>TRUE Statement Translation:</h4>
                            <textarea id="true-statement-translation" placeholder="Translate the TRUE statement..."></textarea>
                        </div>
                        <div class="true-false-section">
                            <h4>FALSE Statement Translation:</h4>
                            <textarea id="false-statement-translation" placeholder="Translate the FALSE statement..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </fieldset>

        <div class="actions">
            <button id="submit-btn" disabled data-tooltip="Please complete all fields before submitting">Submit Annotation</button>
            <button id="reset-btn">Reset</button>
            <button id="not-applicable-btn">Not applicable to my culture</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <!-- Add preview panel -->
        <div id="preview" class="preview-panel"></div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // SECURITY CHECK: Block access without proper URL parameters
            function validateAccess() {
                const urlParams = new URLSearchParams(window.location.search);
                const pilotId = urlParams.get('id');
                const subset = urlParams.get('subset');
                const reset = urlParams.get('reset');
                
                // Check for reset parameter
                if (reset === 'true' && pilotId && subset) {
                    const subsetNum = parseInt(subset);
                    if (subsetNum >= 1 && subsetNum <= 10) {
                        // Clear subset progress
                        localStorage.removeItem(`subset_${subsetNum}_user_${pilotId}_completed`);
                        localStorage.removeItem(`current_template_${pilotId}`);
                        localStorage.removeItem(`template_progress_${pilotId}`);
                        
                        // Clear stored pilot ID and dev user ID to ensure fresh start
                        localStorage.removeItem('pilotId');
                        localStorage.removeItem('devUserId');
                        
                        // Clear fingerprint for this user to regenerate
                        localStorage.removeItem(`fingerprint_${pilotId}`);
                        
                        console.log(`‚úÖ Reset progress for subset ${subsetNum}, user ${pilotId}`);
                        console.log(`‚úÖ Cleared stored IDs and fingerprint`);
                        
                        // Redirect without reset parameter to start fresh
                        window.location.href = `${window.location.pathname}?id=${pilotId}&subset=${subset}`;
                        return false;
                    }
                }
                
                // Check if required parameters are present
                const validPilotIds = ['742891', '586234', '193847', '415672', '829456', '651327', '129431'];
                const hasValidId = pilotId && validPilotIds.includes(pilotId);
                const hasSubset = subset && parseInt(subset) >= 1 && parseInt(subset) <= 10;
                
                if (!hasValidId || !hasSubset) {
                    // Block access - show error message and prevent loading
                    document.body.innerHTML = `
                        <div style="
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            min-height: 100vh; 
                            font-family: Arial, sans-serif;
                            background-color: #f8faff;
                            text-align: center;
                        ">
                            <div style="
                                max-width: 500px;
                                padding: 40px;
                                background: white;
                                border-radius: 12px;
                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            ">
                                <h2 style="color: #dc3545; margin-bottom: 20px;">
                                    <i class="fas fa-lock" style="margin-right: 10px;"></i>
                                    Access Denied
                                </h2>
                                <p style="color: #6c757d; margin-bottom: 20px; line-height: 1.6;">
                                    This annotation interface requires valid authentication parameters. 
                                    Please use the proper access link provided to you.
                                </p>
                                <p style="color: #495057; font-size: 14px;">
                                    If you believe you should have access, please contact the research administrator.
                                </p>
                            </div>
                        </div>
                    `;
                    return false;
                }
                
                return true;
            }
            
            // Run security check first
            if (!validateAccess()) {
                return; // Stop execution if access is denied
            }
            
            // Global variables for user tracking
            let currentUserId = null;
            let deviceFingerprint = null;
            
            // Subset-based template system variables
            let currentSubset = null;
            let subsetTemplates = [];
            let currentTemplateIndex = 0;
            let forceTemplateLoad = false; // Flag to force loading specific template from URL
            
            // Existing global variables
            const loadingDiv = document.getElementById('loading');
            const templateContainer = document.getElementById('template-container');
            const templateText = document.getElementById('template-text');
            const templateNote = document.getElementById('template-note');
            const templateNoteText = document.getElementById('template-note-text');
            const optionATemplate = document.getElementById('option-a-template');
            const optionBTemplate = document.getElementById('option-b-template');
            const optionCTemplate = document.getElementById('option-c-template');
            const optionDTemplate = document.getElementById('option-d-template');
            
            const translationQuestion = document.getElementById('translation-question');
            const translationOptionA = document.getElementById('translation-option-a');
            const translationOptionB = document.getElementById('translation-option-b');
            const translationOptionC = document.getElementById('translation-option-c');
            const translationOptionD = document.getElementById('translation-option-d');
            
            // True-False Questions Elements
            const trueStatementEnglish = document.getElementById('true-statement-english');
            const falseStatementEnglish = document.getElementById('false-statement-english');
            const trueStatementTranslation = document.getElementById('true-statement-translation');
            const falseStatementTranslation = document.getElementById('false-statement-translation');
            
            const submitBtn = document.getElementById('submit-btn');
            const resetBtn = document.getElementById('reset-btn');
            const statusDiv = document.getElementById('status');
            const previewDiv = document.getElementById('preview');
            
            // Current template data
            let currentTemplate = null;
            
            // NEW: Timing and subset tracking
            let templateStartTime = null;
            let currentSubsetId = null;
            let currentTemplatePosition = null;
            
            // Generate device fingerprint using FingerprintJS
            async function generateDeviceFingerprint() {
                try {
                    const fp = await FingerprintJS.load();
                    const result = await fp.get();
                    
                    
                    return result.visitorId;
                } catch (error) {
                    return generateFallbackFingerprint();
                }
            }
            
            // Fallback fingerprinting if FingerprintJS fails
            function generateFallbackFingerprint() {
                const fingerprint = {
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    screenResolution: `${screen.width}x${screen.height}`,
                    platform: navigator.platform,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
                
                const fingerprintString = Object.values(fingerprint).join('|');
                return 'fallback_' + btoa(fingerprintString).replace(/[^a-zA-Z0-9]/g, '').substring(0, 12);
            }
            
            // Get or create consistent device fingerprint
            async function getConsistentFingerprint() {
                // First check if we have a stored fingerprint for this user
                const userId = getUserId();
                const storedFingerprintKey = `fingerprint_${userId}`;
                const storedFingerprint = localStorage.getItem(storedFingerprintKey);
                
                if (storedFingerprint) {
                    return storedFingerprint;
                }
                
                // Generate new fingerprint
                const newFingerprint = await generateDeviceFingerprint();
                
                // Store it for this user
                localStorage.setItem(storedFingerprintKey, newFingerprint);
                
                return newFingerprint;
            }
            
            // Pilot test user demographics mapping
            function getPilotUserDemographics(userId) {
                
                // Pilot IDs for testing
                if (userId === '742891') {
                    return { language: 'Chinese', country: 'China' };
                } else if (userId === '586234') {
                    return { language: 'Indonesian', country: 'Indonesia' };
                } else if (userId === '193847') {
                    return { language: 'Egyptian Arabic', country: 'Egypt' };
                } else if (userId === '415672') {
                    return { language: 'Hindi', country: 'India' };
                } else if (userId === '829456') {
                    return { language: 'Tagalog', country: 'Philippines' };
                } else if (userId === '651327') {
                    return { language: 'Kazakh', country: 'Kazakhstan' };
                } else if (userId === '129431') {
                    return { language: 'Amharic', country: 'Ethiopia' };
                }
                
                return { language: null, country: null };
            }
            
            // Get user ID (Pilot test ready)
            function getUserId() {
                // Check for Pilot ID first (for testing)
                const urlParams = new URLSearchParams(window.location.search);
                const pilotId = urlParams.get('id');
                
                
                if (pilotId && (pilotId === '742891' || pilotId === '586234' || pilotId === '193847' || pilotId === '415672' || pilotId === '829456' || pilotId === '651327' || pilotId === '129431')) {
                    localStorage.setItem('pilotId', pilotId);
                    return pilotId;
                }
                
                // Check if we have stored Pilot ID
                const storedPilotId = localStorage.getItem('pilotId');
                if (storedPilotId && (storedPilotId === '742891' || storedPilotId === '586234' || storedPilotId === '193847' || storedPilotId === '415672' || storedPilotId === '829456' || storedPilotId === '651327' || storedPilotId === '129431')) {
                    return storedPilotId;
                }
                
                // Fallback to development user ID
                let userId = localStorage.getItem('devUserId');
                if (!userId) {
                    userId = 'dev_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8);
                    localStorage.setItem('devUserId', userId);
                }
                
                return userId;
            }
            
            // Get subset parameter from URL
            function getSubsetFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const subset = urlParams.get('subset');
                
                
                if (subset) {
                    const subsetNum = parseInt(subset);
                    if (!isNaN(subsetNum) && subsetNum >= 1 && subsetNum <= 10) {
                        return subsetNum;
                    }
                }
                
                return null;
            }
            
            // Load templates for a specific subset
            async function loadSubsetTemplates(subset) {
                try {
                    
                    const response = await fetch(`/api/templates/subset?subset=${subset}&t=${new Date().getTime()}`);
                    
                    if (!response.ok) {
                        throw new Error('Failed to fetch subset templates: ' + response.status);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.templates || data.templates.length === 0) {
                        throw new Error('No templates found for subset ' + subset);
                    }
                    
                    subsetTemplates = data.templates;
                    currentSubset = subset;
                    
                    // Check if template parameter is provided in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const templateParam = urlParams.get('template');
                    
                    if (templateParam) {
                        // Start at specific template position (1-indexed in URL, 0-indexed internally)
                        const templatePosition = parseInt(templateParam);
                        if (templatePosition >= 1 && templatePosition <= subsetTemplates.length) {
                            currentTemplateIndex = templatePosition - 1;
                            forceTemplateLoad = true; // Force load this template even if completed
                            console.log(`üìç Starting at template ${templatePosition} as specified in URL`);
                        } else {
                            console.warn(`Invalid template parameter: ${templateParam}. Must be between 1 and ${subsetTemplates.length}`);
                            // Fall back to default behavior
                            const completedKey = `subset_${subset}_user_${currentUserId}_completed`;
                            const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                            currentTemplateIndex = completedTemplates.length;
                            forceTemplateLoad = false;
                        }
                    } else {
                        // Set starting index based on completed templates (default behavior)
                        const completedKey = `subset_${subset}_user_${currentUserId}_completed`;
                        const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                        currentTemplateIndex = completedTemplates.length; // Start from next uncompleted template
                        forceTemplateLoad = false;
                    }
                    
                    
                    return true;
                } catch (error) {
                    throw error;
                }
            }
            
            // Get current template from subset (skip completed ones)
            function getCurrentSubsetTemplate() {
                if (!subsetTemplates || subsetTemplates.length === 0) {
                    return null;
                }
                
                // If forceTemplateLoad is true, load the exact template at currentTemplateIndex
                if (forceTemplateLoad) {
                    forceTemplateLoad = false; // Reset flag after using it once
                    if (currentTemplateIndex >= 0 && currentTemplateIndex < subsetTemplates.length) {
                        return subsetTemplates[currentTemplateIndex];
                    }
                }
                
                // Find first uncompleted template starting from currentTemplateIndex
                const completedKey = `subset_${currentSubset}_user_${currentUserId}_completed`;
                const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                
                for (let i = currentTemplateIndex; i < subsetTemplates.length; i++) {
                    const template = subsetTemplates[i];
                    if (!completedTemplates.includes(template.id)) {
                        currentTemplateIndex = i; // Update index to this uncompleted template
                        return template;
                    }
                }
                
                // All templates completed
                return null;
            }
            
            // Move to next template in subset (skip completed ones)
            function moveToNextTemplate() {
                const completedKey = `subset_${currentSubset}_user_${currentUserId}_completed`;
                const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                
                // Find next uncompleted template
                for (let i = currentTemplateIndex + 1; i < subsetTemplates.length; i++) {
                    if (!completedTemplates.includes(subsetTemplates[i].id)) {
                        currentTemplateIndex = i;
                        return true;
                    }
                }
                
                // No more uncompleted templates
                return false;
            }
            
            // Check if all templates in subset are completed
            function isSubsetCompleted() {
                if (!subsetTemplates || !currentSubset || !currentUserId) return false;
                
                const completedKey = `subset_${currentSubset}_user_${currentUserId}_completed`;
                const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                
                // Check if all template IDs are in completed list
                return subsetTemplates.every(template => completedTemplates.includes(template.id));
            }
            
            // Get progress info for display
            function getSubsetProgress() {
                if (!subsetTemplates || !currentSubset || !currentUserId) {
                    return { current: 0, total: 0, subset: null, completed: false };
                }
                
                const completedKey = `subset_${currentSubset}_user_${currentUserId}_completed`;
                const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                
                return {
                    current: completedTemplates.length + 1, // Next template to work on
                    total: subsetTemplates.length,
                    subset: currentSubset,
                    completed: isSubsetCompleted()
                };
            }
            
            // Check for template version changes and reset if needed
            function checkAndResetForNewTemplates() {
                const CURRENT_TEMPLATE_VERSION = "v3.0"; // Update this when you upload new templates
                const storedVersion = localStorage.getItem('templateVersion');
                
                if (storedVersion !== CURRENT_TEMPLATE_VERSION) {
                    
                    // Clear all progress-related localStorage but keep user identification
                    const keysToKeep = [
                        'pilotId',           // Keep pilot ID assignments
                        'devUserId'          // Keep development user IDs
                    ];
                    
                    // Also keep fingerprint data
                    const fingerprintKeys = Object.keys(localStorage).filter(key => key.startsWith('fingerprint_'));
                    keysToKeep.push(...fingerprintKeys);
                    
                    // Get all localStorage keys and remove the ones we don't want to keep
                    const allKeys = Object.keys(localStorage);
                    const keysToRemove = allKeys.filter(key => !keysToKeep.includes(key));
                    
                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // Set the new version
                    localStorage.setItem('templateVersion', CURRENT_TEMPLATE_VERSION);
                    
                } else {
                }
            }

            // Initialize user identification (async)
            async function initUserIdentification() {
                // First check for template version changes and do one-time reset if needed
                checkAndResetForNewTemplates();
                
                currentUserId = getUserId();
                deviceFingerprint = await getConsistentFingerprint();
                
                // Get user demographics
                const demographics = getPilotUserDemographics(currentUserId);
                
                // Store demographics globally for use in submissions
                window.userDemographics = demographics;
                
                // Debug removed for cleaner production code
            }
            
            // Initialize the application
            async function init() {
                try {
                    // Initialize user identification first
                    await initUserIdentification();
                    
                    // Show loading state
                    loadingDiv.style.display = 'block';
                    templateContainer.style.display = 'none';
                    
                    // Check if we're in subset mode
                    const subset = getSubsetFromURL();
                    
                    if (subset) {
                        await initSubsetMode(subset);
                    } else {
                        // Fetch a random template from the server (legacy mode)
                        fetchRandomTemplate();
                    }
                    
                    // Setup action buttons
                    const notApplicableBtn = document.getElementById('not-applicable-btn');
                    submitBtn.addEventListener('click', showPreview);
                    resetBtn.addEventListener('click', resetTemplate);
                    notApplicableBtn.addEventListener('click', function() {
                        showSkipModal();
                    });
                    
                    // Add event listeners for translation inputs to update progress
                    const translationInputs = [
                        translationQuestion, translationOptionA, 
                        translationOptionB, translationOptionC, translationOptionD,
                        trueStatementTranslation, falseStatementTranslation
                    ];
                    
                    translationInputs.forEach(input => {
                        input.addEventListener('input', function() {
                            validateAnnotation();
                            updateProgressBasedOnCompleteness();
                            updatePreview(); // Update preview in real-time if visible
                            saveTemplateProgress(); // Save progress when user types
                        });
                    });
                    
                    // Setup directions panel toggle
                    document.querySelector('.directions-panel h3').addEventListener('click', function() {
                        const content = document.querySelector('.directions-content');
                        const toggle = document.querySelector('.toggle-directions');
                        
                        if (content.style.display === 'none') {
                            content.style.display = 'block';
                            toggle.textContent = '[‚àí]';
                        } else {
                            content.style.display = 'none';
                            toggle.textContent = '[+]';
                        }
                    });
                    
                    // Setup example panel toggle (find the second directions-panel which is the example)
                    const examplePanel = document.querySelectorAll('.directions-panel')[1];
                    if (examplePanel) {
                        examplePanel.querySelector('h3').addEventListener('click', function() {
                            const content = examplePanel.querySelector('.example-content');
                            const toggle = examplePanel.querySelector('.toggle-example');
                            
                            if (content.style.display === 'none') {
                                content.style.display = 'block';
                                toggle.textContent = '[‚àí]';
                            } else {
                                content.style.display = 'none';
                                toggle.textContent = '[+]';
                            }
                        });
                    }
                } catch (error) {
                    // Continue with existing init even if fingerprinting fails
                    currentUserId = getUserId();
                    deviceFingerprint = 'error_' + Date.now();
                    
                    // Store the error fingerprint for consistency
                    const storedFingerprintKey = `fingerprint_${currentUserId}`;
                    localStorage.setItem(storedFingerprintKey, deviceFingerprint);
                    
                    // Show loading state
                    loadingDiv.style.display = 'block';
                    templateContainer.style.display = 'none';
                    
                    // Fetch a template from the server
                    fetchRandomTemplate();
                    
                    // Setup action buttons
                    const notApplicableBtn = document.getElementById('not-applicable-btn');
                    submitBtn.addEventListener('click', showPreview);
                    resetBtn.addEventListener('click', resetTemplate);
                    notApplicableBtn.addEventListener('click', function() {
                        showSkipModal();
                    });
                }
            }
            
            // Initialize subset mode
            async function initSubsetMode(subset) {
                try {
                    // Load all templates for this subset
                    await loadSubsetTemplates(subset);
                    
                    // Load the first template in the subset
                    loadCurrentSubsetTemplate();
                    
                    // Update progress display
                    updateProgressDisplay();
                    
                } catch (error) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'Error loading subset templates: ' + error.message;
                    statusDiv.style.display = 'block';
                }
            }
            
            // Load current template from subset
            function loadCurrentSubsetTemplate() {
                const template = getCurrentSubsetTemplate();
                
                if (!template) {
                    showCompletionMessage();
                    return;
                }
                
                loadTemplate(template);
                updateProgressDisplay();
            }
            
            // Update progress display for subset mode
            function updateProgressDisplay() {
                if (!currentSubset) return;
                
                const progress = getSubsetProgress();
                
                // Update page title or add progress indicator
                const progressElement = document.getElementById('progress-indicator');
                if (progressElement) {
                    progressElement.textContent = `Template ${progress.current} of ${progress.total}`;
                } else {
                    // Add progress indicator to the page if it doesn't exist
                    const progressDiv = document.createElement('div');
                    progressDiv.id = 'progress-indicator';
                    progressDiv.className = 'progress-indicator';
                    progressDiv.textContent = `Template ${progress.current} of ${progress.total}`;
                    
                    // Insert before the template container
                    templateContainer.parentNode.insertBefore(progressDiv, templateContainer);
                }
                
            }
            
            // Show completion message when all templates are done
            function showCompletionMessage() {
                const progress = getSubsetProgress();
                
                loadingDiv.style.display = 'none';
                templateContainer.style.display = 'none';
                
                const completionDiv = document.createElement('div');
                completionDiv.className = 'completion-message';
                completionDiv.innerHTML = `
                    <h2>üéâ Congratulations!</h2>
                    <p>You have successfully completed all ${progress.total} templates.</p>
                    <p>Thank you for your contribution to the Multicultural Reasoning Benchmark!</p>
                    <div class="completion-stats">
                        <div>‚úÖ Templates Completed: ${progress.total}</div>
                        <div>üåç Language: ${getPilotUserDemographics(currentUserId).language || 'Unknown'}</div>
                    </div>
                `;
                
                // Replace the template container with completion message
                templateContainer.parentNode.replaceChild(completionDiv, templateContainer);
            }
            
            // Update progress based on completeness
            function updateProgressBasedOnCompleteness() {
                const allTranslationFields = [
                    translationQuestion.value.trim(),
                    translationOptionA.value.trim(),
                    translationOptionB.value.trim(),
                    translationOptionC.value.trim(),
                    translationOptionD.value.trim()
                ];
                
                const filledCount = allTranslationFields.filter(field => field !== '').length;
                
                if (filledCount === 0) {
                    updateProgressSteps(1);
                } else if (filledCount < 5) {
                    updateProgressSteps(2);
                } else {
                    updateProgressSteps(3);
                }
            }
            
            // Update progress steps
            function updateProgressSteps(step) {
                const steps = document.querySelectorAll('.step');
                steps.forEach((el, index) => {
                    if (index < step) {
                        el.classList.add('active');
                    } else {
                        el.classList.remove('active');
                    }
                });
            }
            
            // Fetch a random template from the server
            async function fetchRandomTemplate() {
                try {
                    
                    // Check if we have a stored template for this user that hasn't been completed
                    const storedTemplateKey = `current_template_${currentUserId}`;
                    const storedTemplate = localStorage.getItem(storedTemplateKey);
                    
                    if (storedTemplate) {
                        try {
                            const parsedTemplate = JSON.parse(storedTemplate);
                            loadTemplate(parsedTemplate);
                            return;
                        } catch (parseError) {
                            localStorage.removeItem(storedTemplateKey);
                        }
                    }
                    
                    // Hide preview if visible
                    previewDiv.style.display = 'none';
                    
                    const response = await fetch('/api/templates/random?t=' + new Date().getTime());
                    
                    if (!response.ok) {
                        throw new Error('Failed to fetch template: ' + response.status);
                    }
                    
                    const template = await response.json();
                    
                    // Store the new template for this user
                    localStorage.setItem(storedTemplateKey, JSON.stringify(template));
                    
                    loadTemplate(template);
                } catch (error) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'Error loading template: ' + error.message;
                    statusDiv.style.display = 'block';
                    
                    createExampleTemplate();
                }
            }
            
            // Clear stored template for user (called after successful submission or skip)
            function clearStoredTemplate() {
                const storedTemplateKey = `current_template_${currentUserId}`;
                const progressKey = `template_progress_${currentUserId}`;
                localStorage.removeItem(storedTemplateKey);
                localStorage.removeItem(progressKey);
            }
            
            // Save progress - simple and reliable
            function saveTemplateProgress() {
                if (!currentUserId || !currentTemplate) {
                    return;
                }
                
                const progressKey = `template_progress_${currentUserId}`;
                const data = {
                    templateId: currentTemplate.id,
                    timestamp: Date.now(),
                    // Translation fields
                    translationQuestion: translationQuestion.value || '',
                    translationOptionA: translationOptionA.value || '',
                    translationOptionB: translationOptionB.value || '',
                    translationOptionC: translationOptionC.value || '',
                    translationOptionD: translationOptionD.value || '',
                    // True-False translation fields
                    trueFalseTranslationTrue: trueStatementTranslation.value || '',
                    trueFalseTranslationFalse: falseStatementTranslation.value || '',
                    // Placeholder fields
                    placeholders: {}
                };
                
                // Get values from input elements only
                document.querySelectorAll('input[data-placeholder-id]').forEach(input => {
                    const id = input.getAttribute('data-placeholder-id');
                    const value = input.value || '';
                    if (value.trim()) {
                        data.placeholders[id] = value.trim();
                    }
                });
                
                localStorage.setItem(progressKey, JSON.stringify(data));
            }
            
            // Restore user progress - FIXED VERSION (cache bust: v2)
            function restoreTemplateProgress() {
                if (!currentUserId || !currentTemplate) {
                    return;
                }
                
                const progressKey = `template_progress_${currentUserId}`;
                const storedProgress = localStorage.getItem(progressKey);
                
                if (!storedProgress) {
                    return;
                }
                
                try {
                    const data = JSON.parse(storedProgress);
                    
                    // Only restore if it's for the same template
                    if (data.templateId !== currentTemplate.id) {
                        localStorage.removeItem(progressKey);
                        return;
                    }
                    
                    
                    // Restore translation fields
                    if (data.translationQuestion || data.translationOptionA || data.translationOptionB || data.translationOptionC || data.translationOptionD) {
                        translationQuestion.value = data.translationQuestion || '';
                        translationOptionA.value = data.translationOptionA || '';
                        translationOptionB.value = data.translationOptionB || '';
                        translationOptionC.value = data.translationOptionC || '';
                        translationOptionD.value = data.translationOptionD || '';
                    }
                    
                    // Restore true-false translation fields
                    if (data.trueFalseTranslationTrue || data.trueFalseTranslationFalse) {
                        trueStatementTranslation.value = data.trueFalseTranslationTrue || '';
                        falseStatementTranslation.value = data.trueFalseTranslationFalse || '';
                    }
                    
                    // Restore placeholder values using a direct approach
                    if (data.placeholders) {
                        
                        Object.entries(data.placeholders).forEach(([id, value]) => {
                            const span = document.querySelector(`span[data-placeholder-id="${id}"]`);
                            if (span && value.trim()) {
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.value = value;
                                input.className = 'placeholder-input';
                                input.setAttribute('data-placeholder-id', id);
                                input.addEventListener('input', saveTemplateProgress);
                                span.parentNode.replaceChild(input, span);
                            }
                        });
                    }
                    
                    // Single validation after restoration
                    setTimeout(() => {
                        validateAnnotation();
                        updateProgressBasedOnCompleteness();
                    }, 500);
                    
                } catch (error) {
                    localStorage.removeItem(progressKey);
                }
            }
            
            // Helper function to restore a single placeholder value
            function restorePlaceholderValue(placeholderId, value) {
                
                // Find all elements with this placeholder ID (for duplicate placeholders)
                let placeholderElements = document.querySelectorAll(`.placeholder[data-placeholder-id="${placeholderId}"]`);
                let inputElement = document.querySelector(`input[data-placeholder-id="${placeholderId}"]`);
                
                if (inputElement) {
                    // Input already exists, just set the value
                    inputElement.value = value;
                    autoResizeInput(inputElement);
                    
                    // Update any synced placeholder displays
                    const syncedPlaceholders = document.querySelectorAll(`.synced-placeholder[data-placeholder-id="${placeholderId}"]`);
                    syncedPlaceholders.forEach(syncedSpan => {
                        syncedSpan.textContent = value;
                        syncedSpan.style.backgroundColor = '#e8f5e8';
                        syncedSpan.style.fontWeight = 'bold';
                    });
                    
                    return true;
                    
                } else if (placeholderElements.length > 0) {
                    // Convert placeholders to input + synced displays
                    const firstPlaceholder = placeholderElements[0];
                    const placeholderText = firstPlaceholder.textContent;
                    
                    // Create input for the first instance
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = value;
                    input.setAttribute('data-placeholder-id', placeholderId);
                    input.placeholder = placeholderText;
                    
                    // Add event listeners
                    addPlaceholderEventListeners(input, placeholderId, placeholderText, placeholderElements.length);
                    
                    // Replace first placeholder with input
                    firstPlaceholder.parentNode.replaceChild(input, firstPlaceholder);
                    
                    // Convert remaining placeholders to synced displays
                    for (let i = 1; i < placeholderElements.length; i++) {
                        const syncSpan = document.createElement('span');
                        syncSpan.className = 'synced-placeholder';
                        syncSpan.setAttribute('data-placeholder-id', placeholderId);
                        syncSpan.textContent = value;
                        syncSpan.style.border = '1px dashed #ccc';
                        syncSpan.style.padding = '2px 5px';
                        syncSpan.style.backgroundColor = '#e8f5e8';
                        syncSpan.style.fontWeight = 'bold';
                        syncSpan.style.cursor = 'pointer';
                        syncSpan.addEventListener('click', () => input.focus());
                        
                        placeholderElements[i].parentNode.replaceChild(syncSpan, placeholderElements[i]);
                    }
                    
                    autoResizeInput(input);
                    return true;
                }
                
                return false;
            }
            
            // Helper function to auto-resize input based on content
            function autoResizeInput(input) {
                // Create a temporary span to measure text width
                const temp = document.createElement('span');
                temp.style.visibility = 'hidden';
                temp.style.position = 'absolute';
                temp.style.fontSize = window.getComputedStyle(input).fontSize;
                temp.style.fontFamily = window.getComputedStyle(input).fontFamily;
                temp.style.fontWeight = window.getComputedStyle(input).fontWeight;
                temp.style.padding = '0';
                temp.style.margin = '0';
                temp.style.border = 'none';
                temp.style.whiteSpace = 'nowrap';
                
                // Use input value or placeholder for measurement
                temp.textContent = input.value || input.placeholder;
                
                document.body.appendChild(temp);
                
                // Set minimum width (based on placeholder) and add some padding
                const minWidth = 120; // minimum width in pixels
                const measuredWidth = temp.offsetWidth + 20; // add 20px padding
                const newWidth = Math.max(minWidth, measuredWidth);
                
                input.style.width = newWidth + 'px';
                
                document.body.removeChild(temp);
            }

            // Helper function to add consistent event listeners to placeholder inputs
            function addPlaceholderEventListeners(input, placeholderId, placeholderText, totalInstances = 1) {
                // Auto-resize on initial creation
                autoResizeInput(input);
                
                input.addEventListener('input', function() {
                    const value = this.value;
                    
                    // Update all synced placeholder displays with the same ID
                    const syncedPlaceholders = document.querySelectorAll(`.synced-placeholder[data-placeholder-id="${placeholderId}"]`);
                    syncedPlaceholders.forEach(syncedSpan => {
                        syncedSpan.textContent = value || placeholderText;
                        if (value) {
                            syncedSpan.style.backgroundColor = '#e8f5e8';
                            syncedSpan.style.fontWeight = 'bold';
                        } else {
                            syncedSpan.style.backgroundColor = '#f9f9f9';
                            syncedSpan.style.fontWeight = 'normal';
                        }
                    });
                    
                    autoResizeInput(this); // Resize as user types
                    validateAnnotation();
                    updateEnglishColumn(); // Update the English column in real-time
                    updateTemplateSection(); // Update the template section in real-time
                    updateTrueFalseQuestions(); // Update true-false questions in real-time
                    updatePreview(); // Update preview in real-time if visible
                    saveTemplateProgress();
                });
                
                input.addEventListener('blur', function() {
                    saveTemplateProgress(); // Always save on blur
                    updateEnglishColumn(); // Update the English column when done editing
                    updateTemplateSection(); // Update the template section when done editing
                    
                    if (this.value.trim() === '') {
                        // Convert back to ALL placeholder instances if empty
                        const syncedPlaceholders = document.querySelectorAll(`.synced-placeholder[data-placeholder-id="${placeholderId}"]`);
                        
                        // Replace the input with a placeholder
                        const newPlaceholder = createPlaceholder(placeholderId, placeholderText);
                        this.parentNode.replaceChild(newPlaceholder, this);
                        
                        // Convert all synced spans back to placeholders
                        syncedPlaceholders.forEach(syncedSpan => {
                            const newPlaceholder = createPlaceholder(placeholderId, placeholderText);
                            syncedSpan.parentNode.replaceChild(newPlaceholder, syncedSpan);
                        });
                        
                        // Re-initialize placeholders after conversion
                        initPlaceholders();
                        
                        validateAnnotation();
                        updateEnglishColumn(); // Update again after converting back to placeholder
                        updateTemplateSection(); // Update template section after converting back to placeholder
                        saveTemplateProgress();
                    }
                });
            }
            
            // Function to get template examples based on template ID or type
            function getTemplateExample(templateId, templateCategory) {
                // This would ideally come from your server, but here's a static example mapping
                const examples = {
                    // Spatial reasoning example
                    8: {
                        question: "Which of the following is the furthest from Jakarta?",
                        optionA: "London (correct - 11,716 km)",
                        optionB: "Manila (2,294 km)",
                        optionC: "Bangkok (2,361 km)",
                        optionD: "Singapore (884 km)"
                    },
                    // Food example - template for "not originally from" questions
                    1: {
                        question: "Among all the food here, which one is not originally from Indonesia?",
                        optionA: "Shawarma (Middle Eastern dish)",
                        optionB: "Kerak Telor (traditional Betawi dish)",
                        optionC: "Ketoprak (traditional Javanese dish)",
                        optionD: "Soto Betawi (traditional dish from Jakarta)"
                    },
                    // Cultural example - proverbs
                    2: {
                        question: "If the proverb 'A stitch in time saves nine' is associated with English, which proverb would be associated with Indonesian?",
                        optionA: "Ada ubi, ada talas, ada budi, ada balas (There are sweet potatoes, there are taros, there are kindnesses, there are returns)",
                        optionB: "Out of sight, out of mind",
                        optionC: "The early bird catches the worm",
                        optionD: "Don't count your chickens before they hatch"
                    },
                    // Wedding traditions
                    3: {
                        question: "In a traditional Javanese wedding, which ceremony involves the bride washing the groom's feet?",
                        optionA: "Siraman (correct answer)",
                        optionB: "Midodareni",
                        optionC: "Pengajian",
                        optionD: "Seserahan"
                    },
                    // Default example for any template
                    default: {
                        question: "This is an example of how this question might look when completed.",
                        optionA: "This is the correct option with relevant details",
                        optionB: "This is an incorrect option",
                        optionC: "This is another incorrect option",
                        optionD: "This is the final incorrect option"
                    }
                };
                
                // Try to match by template ID first
                if (examples[templateId]) {
                    return examples[templateId];
                }
                
                // If no match by ID, try to match by category keywords
                if (templateCategory) {
                    if (templateCategory.includes("Food")) {
                        return examples[1];
                    } else if (templateCategory.includes("Spatial") || templateCategory.includes("Geographic")) {
                        return examples[8];
                    } else if (templateCategory.includes("Cultural") || templateCategory.includes("Proverb")) {
                        return examples[2];
                    } else if (templateCategory.includes("Wedding") || templateCategory.includes("Ceremony")) {
                        return examples[3];
                    }
                }
                
                // Return default if no matches found
                return examples.default;
            }
            
            // NEW: Detect subset and template position (handles normal + deep-link cases)
            function detectSubsetAndPosition() {
                // Check URL for subset parameter (?subset=A)
                const urlParams = new URLSearchParams(window.location.search);
                const subsetFromUrl = urlParams.get('subset');
                
                if (subsetFromUrl) {
                    currentSubsetId = subsetFromUrl;
                    
                    if (Number.isInteger(currentTemplateIndex) && currentTemplateIndex >= 0) {
                        // We know exactly which template in the subset is loaded right now
                        currentTemplatePosition = currentTemplateIndex + 1;
                    } else {
                        // Fallback to progress tracking (next unfinished template)
                        const completedKey = `subset_${currentSubsetId}_user_${currentUserId}_completed`;
                        const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                        const nextPosition = completedTemplates.length + 1;
                        if (subsetTemplates && subsetTemplates.length > 0) {
                            currentTemplatePosition = Math.min(nextPosition, subsetTemplates.length);
                        } else {
                            currentTemplatePosition = nextPosition;
                        }
                    }
                    
                } else {
                    // Random mode - no subset
                    currentSubsetId = null;
                    currentTemplatePosition = null;
                }
            }
            
            // NEW: Mark template as completed in localStorage
            function markTemplateCompleted(templateId) {
                if (!currentSubsetId || !currentUserId || !templateId) {
                    return;
                }
                
                const completedKey = `subset_${currentSubsetId}_user_${currentUserId}_completed`;
                const completedTemplates = JSON.parse(localStorage.getItem(completedKey) || '[]');
                
                // Add template ID if not already completed
                if (!completedTemplates.includes(templateId)) {
                    completedTemplates.push(templateId);
                    localStorage.setItem(completedKey, JSON.stringify(completedTemplates));
                }
            }
                    
            // Create a sample template for development/testing
            function createExampleTemplate() {
                const template = {
                    id: 8,
                    template: "Which of the following is the furthest from [CITY]?",
                    category: "Mathematical Reasoning, Multi-hop Reasoning, Spatial Reasoning - Landmarks and Architecture",
                    template_text: `Which of the following is the furthest from <span class="placeholder" data-placeholder-id="CITY">[CITY]</span>?`,
                    option_a: `<span class="placeholder" data-placeholder-id="CORRECT_OPTION">[The city that is geographically furthest]</span>`,
                    option_b: `<span class="placeholder" data-placeholder-id="WRONG_OPTION_1">[Cities that are geographically closer]</span>`,
                    option_c: `<span class="placeholder" data-placeholder-id="WRONG_OPTION_2">[Cities that are geographically closer]</span>`,
                    option_d: `<span class="placeholder" data-placeholder-id="WRONG_OPTION_3">[Cities that are geographically closer]</span>`
                };
                
                loadTemplate(template);
            }
            // Load a template into the UI
            function loadTemplate(template) {
                currentTemplate = template;
                
                // Function to convert \n to <br> for proper line breaks
                function formatLineBreaks(text) {
                    if (!text) return text;
                    return text.replace(/\\n/g, '<br>');
                }
                
                // Update template text for question
                templateText.innerHTML = formatLineBreaks(template.template_text);
                
                // Handle template note display
                if (template.note && template.note.trim() !== '') {
                    templateNoteText.innerHTML = formatLineBreaks(template.note.trim());
                    templateNote.style.display = 'block';
                } else {
                    templateNote.style.display = 'none';
                }
                
                // Update template text for options - use the actual template content from CSV
                optionATemplate.innerHTML = formatLineBreaks(template.option_a) || '<span class="placeholder" data-placeholder-id="CORRECT_OPTION">[The correct option]</span>';
                optionBTemplate.innerHTML = formatLineBreaks(template.option_b) || '<span class="placeholder" data-placeholder-id="WRONG_OPTION_1">[An incorrect option]</span>';
                optionCTemplate.innerHTML = formatLineBreaks(template.option_c) || '<span class="placeholder" data-placeholder-id="WRONG_OPTION_2">[An incorrect option]</span>';
                optionDTemplate.innerHTML = formatLineBreaks(template.option_d) || '<span class="placeholder" data-placeholder-id="WRONG_OPTION_3">[An incorrect option]</span>';
                
                // Initialize true-false questions with visible placeholders (non-clickable)
                if (template.child_template_true && template.child_template_false) {
                    // Show template with placeholders visible but not clickable
                    trueStatementEnglish.textContent = template.child_template_true;
                    falseStatementEnglish.textContent = template.child_template_false;
                    trueStatementEnglish.classList.remove('filled');
                    falseStatementEnglish.classList.remove('filled');
                } else {
                    trueStatementEnglish.textContent = 'No TRUE template available for this question';
                    falseStatementEnglish.textContent = 'No FALSE template available for this question';
                    trueStatementEnglish.classList.remove('filled');
                    falseStatementEnglish.classList.remove('filled');
                }
                trueStatementTranslation.value = '';
                falseStatementTranslation.value = '';
                
                // Setup placeholder functionality for question and options (do this immediately after setting innerHTML)
                initPlaceholders();
                
                // Load example directly from template data
                if (template.example) {
                    document.getElementById('example-question').innerHTML = formatLineBreaks(template.example.question) || "Example question not available";
                    document.getElementById('example-option-a').innerHTML = formatLineBreaks(template.example.optionA) || "Example option A not available";
                    document.getElementById('example-option-b').innerHTML = formatLineBreaks(template.example.optionB) || "Example option B not available";
                    document.getElementById('example-option-c').innerHTML = formatLineBreaks(template.example.optionC) || "Example option C not available";
                    document.getElementById('example-option-d').innerHTML = formatLineBreaks(template.example.optionD) || "Example option D not available";
                } else {
                    // Fallback to getTemplateExample function if no example in the template data
                    const example = getTemplateExample(template.id, template.category);
                    document.getElementById('example-question').innerHTML = formatLineBreaks(example.question);
                    document.getElementById('example-option-a').innerHTML = formatLineBreaks(example.optionA);
                    document.getElementById('example-option-b').innerHTML = formatLineBreaks(example.optionB);
                    document.getElementById('example-option-c').innerHTML = formatLineBreaks(example.optionC);
                    document.getElementById('example-option-d').innerHTML = formatLineBreaks(example.optionD);
                }
                
                // Clear translation fields
                translationQuestion.value = '';
                translationOptionA.value = '';
                translationOptionB.value = '';
                translationOptionC.value = '';
                translationOptionD.value = '';
                
                // Reset status
                statusDiv.className = 'status';
                statusDiv.textContent = '';
                statusDiv.style.display = 'none';
                
                // Hide loading state
                loadingDiv.style.display = 'none';
                templateContainer.style.display = 'block';
                
                // Reset progress steps
                updateProgressSteps(1);
                
                // NEW: Start timing the template interaction
                templateStartTime = Date.now();
                
                // NEW: Detect subset and position from URL or template
                detectSubsetAndPosition();
                
                // Start auto-save for this template - DISABLED FOR TESTING
                // startAutoSave();
                
                // Restore any saved progress for this template
                restoreTemplateProgress();
                
                // Add a small delay and re-validate to ensure everything is properly restored
                setTimeout(() => {
                    validateAnnotation();
                    updateProgressBasedOnCompleteness();
                }, 1000);
                
                // Initial validation
                validateAnnotation();
            }
            
            // Initialize placeholder functionality
            function initPlaceholders() {
                const placeholders = document.querySelectorAll('.placeholder');
                
                // Group placeholders by their ID to handle duplicates properly
                const placeholderGroups = {};
                placeholders.forEach(placeholder => {
                    const placeholderId = placeholder.getAttribute('data-placeholder-id');
                    if (!placeholderGroups[placeholderId]) {
                        placeholderGroups[placeholderId] = [];
                    }
                    placeholderGroups[placeholderId].push(placeholder);
                });
                
                // Process each group
                Object.keys(placeholderGroups).forEach(placeholderId => {
                    const group = placeholderGroups[placeholderId];
                    if (group.length === 0) return;
                    
                    const placeholderText = group[0].textContent;
                    
                    // Add click listener to all placeholders in this group
                    group.forEach(placeholder => {
                        placeholder.addEventListener('click', function() {
                            // Check if there's already an input for this placeholder ID
                            const existingInput = document.querySelector(`input[data-placeholder-id="${placeholderId}"]`);
                            if (existingInput) {
                                existingInput.focus();
                                return;
                            }
                            
                            // Create ONE input field that will be shared
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.value = '';
                            input.setAttribute('data-placeholder-id', placeholderId);
                            input.placeholder = placeholderText;
                            
                            // Add event listeners with sync functionality
                            addPlaceholderEventListeners(input, placeholderId, placeholderText, group.length);
                            
                            // Replace the FIRST instance with input
                            const firstPlaceholder = group[0];
                            firstPlaceholder.parentNode.replaceChild(input, firstPlaceholder);
                            
                            // Convert ALL remaining instances to synced display spans
                            for (let i = 1; i < group.length; i++) {
                                const syncSpan = document.createElement('span');
                                syncSpan.className = 'synced-placeholder';
                                syncSpan.setAttribute('data-placeholder-id', placeholderId);
                                syncSpan.textContent = placeholderText; // Start with placeholder text
                                syncSpan.style.border = '1px dashed #ccc';
                                syncSpan.style.padding = '2px 5px';
                                syncSpan.style.backgroundColor = '#f9f9f9';
                                syncSpan.style.cursor = 'pointer';
                                syncSpan.addEventListener('click', () => input.focus());
                                
                                group[i].parentNode.replaceChild(syncSpan, group[i]);
                            }
                            
                            // Focus on the new input
                            input.focus();
                            
                            // Initial validation and save
                            validateAnnotation();
                            updateEnglishColumn(); // Update English column when placeholder becomes input
                            updateTemplateSection(); // Update template section when placeholder becomes input
                            saveTemplateProgress();
                        });
                    });
                });
            }
            
            // Create a placeholder element
            function createPlaceholder(id, text) {
                const placeholder = document.createElement('span');
                placeholder.className = 'placeholder';
                placeholder.setAttribute('data-placeholder-id', id);
                placeholder.textContent = text;
                
                placeholder.addEventListener('click', function() {
                    const placeholderId = this.getAttribute('data-placeholder-id');
                    const placeholderText = this.textContent;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = '';
                    input.setAttribute('data-placeholder-id', placeholderId);
                    input.placeholder = placeholderText;
                    
                    // Add consistent event listeners
                    addPlaceholderEventListeners(input, placeholderId, placeholderText);
                    
                    this.parentNode.replaceChild(input, this);
                    input.focus();
                    
                    validateAnnotation();
                    updateEnglishColumn(); // Update English column when placeholder becomes input
                    updateTemplateSection(); // Update template section when placeholder becomes input
                    saveTemplateProgress();
                });
                
                return placeholder;
            }
            
            // Function to update the English column with real-time content
            // Function to update the English column with real-time content
            function updateEnglishColumn() {
                try {
                    const completed = getCompletedQuestion();
                    
                    // Update question display
                    const questionDisplay = document.getElementById('english-question-display');
                    const englishOptionA = document.getElementById('english-option-a');
                    const englishOptionB = document.getElementById('english-option-b');
                    const englishOptionC = document.getElementById('english-option-c');
                    const englishOptionD = document.getElementById('english-option-d');
                    
                    // Check if we have any filled placeholders (better check than comparing to template)
                    const hasFilledPlaceholders = completed.placeholderValues && Object.keys(completed.placeholderValues).length > 0;
                    
                    if (hasFilledPlaceholders && completed.question) {
                        // Convert \n to <br> for proper line breaks in HTML
                        const formattedQuestion = completed.question.replace(/\n/g, '<br>');
                        questionDisplay.innerHTML = formattedQuestion;
                        questionDisplay.classList.add('filled');
                    } else {
                        questionDisplay.textContent = 'Complete the template above to see your question here';
                        questionDisplay.classList.remove('filled');
                    }
                    
                    // Update options
                    const options = [
                        { elem: englishOptionA, value: completed.optionA, placeholder: 'Fill template to see option A' },
                        { elem: englishOptionB, value: completed.optionB, placeholder: 'Fill template to see option B' },
                        { elem: englishOptionC, value: completed.optionC, placeholder: 'Fill template to see option C' },
                        { elem: englishOptionD, value: completed.optionD, placeholder: 'Fill template to see option D' }
                    ];
                    
                    options.forEach(option => {
                        if (option.value && option.value.trim() && !option.value.includes('not provided')) {
                            option.elem.textContent = option.value;
                            option.elem.classList.add('filled');
                        } else {
                            option.elem.textContent = option.placeholder;
                            option.elem.classList.remove('filled');
                        }
                    });
                    
                } catch (error) {
                }
            }
            
            // Function to update the template section in real-time
            function updateTemplateSection() {
                // Update all synced placeholders in the template section to match their corresponding inputs
                const inputs = document.querySelectorAll('input[data-placeholder-id]');
                
                inputs.forEach(input => {
                    const placeholderId = input.getAttribute('data-placeholder-id');
                    const value = input.value;
                    
                    // Find all synced placeholder spans with the same ID
                    const syncedSpans = document.querySelectorAll(`.synced-placeholder[data-placeholder-id="${placeholderId}"]`);
                    
                    syncedSpans.forEach(span => {
                        // Update the display text to match the input value or show placeholder text if empty
                        if (value.trim()) {
                            span.textContent = value;
                            span.style.backgroundColor = '#e8f5e8'; // Light green to indicate filled
                        } else {
                            span.textContent = input.placeholder;
                            span.style.backgroundColor = '#f9f9f9'; // Light gray for empty
                        }
                    });
                });
            }
            
            // Function to update true-false questions with real-time content
            function updateTrueFalseQuestions() {
                if (!currentTemplate) {
                    return;
                }
                
                if (!currentTemplate.child_template_true || !currentTemplate.child_template_false) {
                    // Show original template text if no child templates
                    trueStatementEnglish.textContent = 'No TRUE template available for this question';
                    falseStatementEnglish.textContent = 'No FALSE template available for this question';
                    trueStatementEnglish.classList.remove('filled');
                    falseStatementEnglish.classList.remove('filled');
                    return;
                }
                
                try {
                    const completed = getCompletedQuestion();
                    
                    // Start with original templates
                    let trueStatement = currentTemplate.child_template_true;
                    let falseStatement = currentTemplate.child_template_false;
                    let hasUpdates = false;
                    
                    // Replace user placeholders (like [FAMOUS PERSON]) if available
                    if (completed.placeholderValues && Object.keys(completed.placeholderValues).length > 0) {
                        Object.entries(completed.placeholderValues).forEach(([placeholder, value]) => {
                            const regex = new RegExp(`\\[${placeholder}\\]`, 'g');
                            trueStatement = trueStatement.replace(regex, value);
                            falseStatement = falseStatement.replace(regex, value);
                            hasUpdates = true;
                        });
                    }
                    
                    // Replace [OPTION A], [OPTION B], etc. with user-filled option values
                    // Map the correct placeholder values to option letters (safely)
                    const placeholderValues = completed.placeholderValues || {};
                    const optionA_value = placeholderValues['CORRECT_OPTION'];
                    const optionB_value = placeholderValues['WRONG_OPTION_1'];
                    const optionC_value = placeholderValues['WRONG_OPTION_2'];
                    const optionD_value = placeholderValues['WRONG_OPTION_3'];
                    
                    if (optionA_value) {
                        trueStatement = trueStatement.replace(/\[OPTION A\]/g, optionA_value);
                        falseStatement = falseStatement.replace(/\[OPTION A\]/g, optionA_value);
                        hasUpdates = true;
                    }
                    if (optionB_value) {
                        trueStatement = trueStatement.replace(/\[OPTION B\]/g, optionB_value);
                        falseStatement = falseStatement.replace(/\[OPTION B\]/g, optionB_value);
                        hasUpdates = true;
                    }
                    if (optionC_value) {
                        trueStatement = trueStatement.replace(/\[OPTION C\]/g, optionC_value);
                        falseStatement = falseStatement.replace(/\[OPTION C\]/g, optionC_value);
                        hasUpdates = true;
                    }
                    if (optionD_value) {
                        trueStatement = trueStatement.replace(/\[OPTION D\]/g, optionD_value);
                        falseStatement = falseStatement.replace(/\[OPTION D\]/g, optionD_value);
                        hasUpdates = true;
                    }
                    
                    // Update the display divs
                    trueStatementEnglish.textContent = trueStatement;
                    falseStatementEnglish.textContent = falseStatement;
                    
                    // Add filled class if we have updates
                    if (hasUpdates) {
                        trueStatementEnglish.classList.add('filled');
                        falseStatementEnglish.classList.add('filled');
                    } else {
                        trueStatementEnglish.classList.remove('filled');
                        falseStatementEnglish.classList.remove('filled');
                    }
                    
                } catch (error) {
                    // Silently handle errors
                }
            }
            
            // Validation function to check if all fields are filled
            function validateAnnotation() {
                const placeholders = document.querySelectorAll('.placeholder');
                const inputs = document.querySelectorAll('input[data-placeholder-id]');
                let isValid = true;
                let missingFields = [];
                
                // Update the English column with real-time content
                updateEnglishColumn();
                updateTemplateSection();
                updateTrueFalseQuestions(); // Update true-false questions
                
                // Debug: List all placeholders found
                placeholders.forEach((placeholder, index) => {
                    const id = placeholder.getAttribute('data-placeholder-id');
                    const text = placeholder.textContent;
                });
                
                // Debug: List all inputs found
                inputs.forEach((input, index) => {
                    const id = input.getAttribute('data-placeholder-id');
                    const value = input.value || '';
                });
                
                // Check if any placeholders are still visible (not converted to inputs)
                // Group by unique placeholder IDs to avoid counting duplicates
                const uniquePlaceholderIds = new Set();
                placeholders.forEach(placeholder => {
                    const placeholderId = placeholder.getAttribute('data-placeholder-id');
                    uniquePlaceholderIds.add(placeholderId);
                });
                
                if (uniquePlaceholderIds.size > 0) {
                    isValid = false;
                    uniquePlaceholderIds.forEach(placeholderId => {
                        missingFields.push(placeholderId);
                    });
                }
                
                // Check if any inputs are empty
                inputs.forEach(input => {
                    const placeholderId = input.getAttribute('data-placeholder-id');
                    const value = input.value ? input.value.trim() : '';
                    if (!value) {
                        isValid = false;
                        missingFields.push(placeholderId);
                    }
                });
                
                // Check if all translation fields are provided
                const translationFields = [
                    { elem: translationQuestion, name: 'Question Translation', id: 'translation-question' },
                    { elem: translationOptionA, name: 'Option A Translation', id: 'translation-option-a' },
                    { elem: translationOptionB, name: 'Option B Translation', id: 'translation-option-b' },
                    { elem: translationOptionC, name: 'Option C Translation', id: 'translation-option-c' },
                    { elem: translationOptionD, name: 'Option D Translation', id: 'translation-option-d' },
                    { elem: trueStatementTranslation, name: 'TRUE Statement Translation', id: 'true-statement-translation' },
                    { elem: falseStatementTranslation, name: 'FALSE Statement Translation', id: 'false-statement-translation' }
                ];
                
                // Debug: Check if true-false elements exist and have values
                console.log('True statement element exists:', !!trueStatementTranslation);
                console.log('False statement element exists:', !!falseStatementTranslation);
                if (trueStatementTranslation) console.log('True statement value:', trueStatementTranslation.value);
                if (falseStatementTranslation) console.log('False statement value:', falseStatementTranslation.value);
                
                translationFields.forEach(field => {
                    if (!field.elem) {
                        console.error(`Element not found for field: ${field.name}`);
                        isValid = false;
                        missingFields.push(field.name + ' (element not found)');
                        return;
                    }
                    
                    const value = field.elem.value ? field.elem.value.trim() : '';
                    const isEmpty = !value;
                    if (isEmpty) {
                        isValid = false;
                        missingFields.push(field.name);
                    }
                });
                
                
                // Update submit button state
                const previousDisabled = submitBtn.disabled;
                submitBtn.disabled = !isValid;
                
                
                // Update tooltip
                if (!isValid) {
                    const tooltip = `Please complete: ${missingFields.join(', ')}`;
                    submitBtn.setAttribute('data-tooltip', tooltip);
                } else {
                    submitBtn.setAttribute('data-tooltip', '');
                }
                
                
                return isValid;
            }
            
            // Get completed question with filled-in values
            function getCompletedQuestion() {
                // Get all inputs with placeholder values
                const inputs = document.querySelectorAll('input[data-placeholder-id]');
                const placeholderValues = {};
                
                // Build a map of placeholder IDs to their values
                inputs.forEach(input => {
                    const id = input.getAttribute('data-placeholder-id');
                    const value = input.value.trim();
                    if (value) {
                        placeholderValues[id] = value;
                    }
                });
                
                
                // Create a simplified version of the completed question
                let question = currentTemplate.template; // Use the original template text
                
                // Replace placeholders in the question with actual values
                Object.keys(placeholderValues).forEach(key => {
                    question = question.replaceAll(`[${key}]`, placeholderValues[key]);
                });
                
                // Convert \n to actual line breaks for display
                question = question.replace(/\\n/g, '\n');
                
                // SIMPLIFIED APPROACH: Just use direct placeholder values for options
                let optionA = placeholderValues['CORRECT_OPTION'] || "Correct option not provided";
                let optionB = placeholderValues['WRONG_OPTION_1'] || "Wrong option 1 not provided";
                let optionC = placeholderValues['WRONG_OPTION_2'] || "Wrong option 2 not provided";
                let optionD = placeholderValues['WRONG_OPTION_3'] || "Wrong option 3 not provided";
                

                
                return {
                    question,
                    optionA, 
                    optionB,
                    optionC,
                    optionD,
                    placeholderValues
                };
            }
            
            // Update preview content with current values (real-time updates)
            function updatePreview() {
                if (previewDiv.style.display !== 'block') {
                    return; // Don't update if preview is not visible
                }
                
                // Get current completed values
                const completed = getCompletedQuestion();
                
                // Get current translation values
                const translatedQuestion = translationQuestion.value;
                const translatedOptionA = translationOptionA.value;
                const translatedOptionB = translationOptionB.value;
                const translatedOptionC = translationOptionC.value;
                const translatedOptionD = translationOptionD.value;
                
                // Update the preview content (keep the existing structure but update content)
                const previewContent = previewDiv.querySelector('.preview-content');
                if (previewContent) {
                    previewContent.innerHTML = `
                        <fieldset>
                            <legend>Completed Question</legend>
                            <p><strong>Question:</strong></p>
                            <div class="preview-question">${completed.question.replace(/\n/g, '<br>')}</div>
                            
                            <p><strong>Options:</strong></p>
                            <div class="options-container">
                                <div class="option-item correct-option">
                                    <div class="option-label">A.</div>
                                    <div class="option-content">${completed.optionA}</div>
                                    <div class="correct-marker">Correct Answer</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">B.</div>
                                    <div class="option-content">${completed.optionB}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">C.</div>
                                    <div class="option-content">${completed.optionC}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">D.</div>
                                    <div class="option-content">${completed.optionD}</div>
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Translation</legend>
                            <p><strong>Question:</strong></p>
                            <div class="preview-question">${translatedQuestion.replace(/\n/g, '<br>')}</div>
                            
                            <p><strong>Options:</strong></p>
                            <div class="options-container">
                                <div class="option-item correct-option">
                                    <div class="option-label">A.</div>
                                    <div class="option-content">${translatedOptionA}</div>
                                    <div class="correct-marker">Correct Answer</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">B.</div>
                                    <div class="option-content">${translatedOptionB}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">C.</div>
                                    <div class="option-content">${translatedOptionC}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">D.</div>
                                    <div class="option-content">${translatedOptionD}</div>
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>True-False Questions</legend>
                            <div class="true-false-preview">
                                <div class="true-false-item">
                                    <p><strong>TRUE Statement (English):</strong></p>
                                    <div class="statement-content">${trueStatementEnglish.textContent}</div>
                                    <p><strong>TRUE Statement (Translation):</strong></p>
                                    <div class="statement-content translation">${trueStatementTranslation.value}</div>
                                </div>
                                
                                <div class="true-false-item">
                                    <p><strong>FALSE Statement (English):</strong></p>
                                    <div class="statement-content">${falseStatementEnglish.textContent}</div>
                                    <p><strong>FALSE Statement (Translation):</strong></p>
                                    <div class="statement-content translation">${falseStatementTranslation.value}</div>
                                </div>
                            </div>
                        </fieldset>
                    `;
                }
            }

            // Show preview before submission
            function showPreview() {
                if (!validateAnnotation()) {
                    return;
                }
                
                // Update progress to step 3
                updateProgressSteps(3);
                
                // Get completed values
                const completed = getCompletedQuestion();
                
                // Get translation values
                const translatedQuestion = translationQuestion.value;
                const translatedOptionA = translationOptionA.value;
                const translatedOptionB = translationOptionB.value;
                const translatedOptionC = translationOptionC.value;
                const translatedOptionD = translationOptionD.value;
                
                // Build preview HTML
                previewDiv.innerHTML = `
                    <h3>Preview before submission:</h3>
                    <div class="preview-content">
                        <fieldset>
                            <legend>Completed Question</legend>
                            <p><strong>Question:</strong></p>
                            <div class="preview-question">${completed.question.replace(/\n/g, '<br>')}</div>
                            
                            <p><strong>Options:</strong></p>
                            <div class="options-container">
                                <div class="option-item correct-option">
                                    <div class="option-label">A.</div>
                                    <div class="option-content">${completed.optionA}</div>
                                    <div class="correct-marker">Correct Answer</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">B.</div>
                                    <div class="option-content">${completed.optionB}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">C.</div>
                                    <div class="option-content">${completed.optionC}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">D.</div>
                                    <div class="option-content">${completed.optionD}</div>
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Translation</legend>
                            <p><strong>Question:</strong></p>
                            <div class="preview-question">${translatedQuestion.replace(/\n/g, '<br>')}</div>
                            
                            <p><strong>Options:</strong></p>
                            <div class="options-container">
                                <div class="option-item correct-option">
                                    <div class="option-label">A.</div>
                                    <div class="option-content">${translatedOptionA}</div>
                                    <div class="correct-marker">Correct Answer</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">B.</div>
                                    <div class="option-content">${translatedOptionB}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">C.</div>
                                    <div class="option-content">${translatedOptionC}</div>
                                </div>
                                <div class="option-item">
                                    <div class="option-label">D.</div>
                                    <div class="option-content">${translatedOptionD}</div>
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>True-False Questions</legend>
                            <div class="true-false-preview">
                                <div class="true-false-item">
                                    <p><strong>TRUE Statement (English):</strong></p>
                                    <div class="statement-content">${trueStatementEnglish.textContent}</div>
                                    <p><strong>TRUE Statement (Translation):</strong></p>
                                    <div class="statement-content translation">${trueStatementTranslation.value}</div>
                                </div>
                                
                                <div class="true-false-item">
                                    <p><strong>FALSE Statement (English):</strong></p>
                                    <div class="statement-content">${falseStatementEnglish.textContent}</div>
                                    <p><strong>FALSE Statement (Translation):</strong></p>
                                    <div class="statement-content translation">${falseStatementTranslation.value}</div>
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    <div class="preview-actions">
                        <button id="confirm-submit">Confirm Submission</button>
                        <button id="cancel-preview">Edit More</button>
                    </div>
                `;
                
                previewDiv.style.display = 'block';
                
                // Add event listeners to buttons
                document.getElementById('confirm-submit').addEventListener('click', submitAnnotation);
                document.getElementById('cancel-preview').addEventListener('click', () => {
                    previewDiv.style.display = 'none';
                    updateProgressSteps(2); // Go back to step 2
                });
                
                // Add real-time update listeners to all input fields
                setupPreviewUpdateListeners();
            }
            
            // Setup event listeners for real-time preview updates
            function setupPreviewUpdateListeners() {
                // Translation field listeners
                const translationInputs = [
                    translationQuestion, translationOptionA, 
                    translationOptionB, translationOptionC, translationOptionD,
                    trueStatementTranslation, falseStatementTranslation
                ];
                
                translationInputs.forEach(input => {
                    if (input) {
                        // Remove existing preview listeners to avoid duplicates
                        input.removeEventListener('input', updatePreview);
                        // Add new listener
                        input.addEventListener('input', updatePreview);
                    }
                });
                
                // Placeholder input listeners (dynamic inputs)
                function addPlaceholderListeners() {
                    const placeholderInputs = document.querySelectorAll('input[data-placeholder-id]');
                    placeholderInputs.forEach(input => {
                        // Remove existing preview listeners to avoid duplicates
                        input.removeEventListener('input', updatePreview);
                        // Add new listener
                        input.addEventListener('input', updatePreview);
                    });
                }
                
                // Add listeners to existing placeholder inputs
                addPlaceholderListeners();
                
                // Also add listeners when new placeholder inputs are created
                // We'll need to modify the addPlaceholderEventListeners function for this
            }
            
            // Submit the annotation
            function submitAnnotation() {
                // Validate before submission
                if (!validateAnnotation()) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'Please fill in all required fields before submitting.';
                    statusDiv.style.display = 'block';
                    return;
                }
                
                // Get completed values
                const completed = getCompletedQuestion();
                
                // Check if options are empty and provide fallback text
                if (!completed.optionA || completed.optionA.trim() === '') {
                }
                if (!completed.optionB || completed.optionB.trim() === '') {
                }
                if (!completed.optionC || completed.optionC.trim() === '') {
                }
                if (!completed.optionD || completed.optionD.trim() === '') {
                }
                
                // Get user demographics
                const demographics = window.userDemographics || getPilotUserDemographics(currentUserId);
                
                // Collect the question data
                const questionData = {
                    template_id: currentTemplate.id,
                    reasoning_category: currentTemplate.reasoning_category || '',
                    cultural_aspect: currentTemplate.cultural_aspect || '',
                    original_template: currentTemplate.template,
                    values: {},
                    
                    // Make sure these are never empty by providing fallbacks
                    generated_question: completed.question || "Question not available",
                    generated_option1: completed.optionA || "Option A not available",
                    generated_option2: completed.optionB || "Option B not available",
                    generated_option3: completed.optionC || "Option C not available", 
                    generated_option4: completed.optionD || "Option D not available",
                    
                    // Translated content
                    translated_question: translationQuestion.value,
                    translated_option1: translationOptionA.value,
                    translated_option2: translationOptionB.value,
                    translated_option3: translationOptionC.value,
                    translated_option4: translationOptionD.value,
                    
                    // True-False questions and translations
                    true_question_english: trueStatementEnglish.textContent,
                    false_question_english: falseStatementEnglish.textContent,
                    true_question_translation: trueStatementTranslation.value,
                    false_question_translation: falseStatementTranslation.value,
                    
                    // Add user tracking data
                    user_id: currentUserId,
                    device_fingerprint: deviceFingerprint,
                    
                    // Add demographics data
                    language: demographics.language,
                    country: demographics.country,
                    
                    // NEW: Add subset tracking and timing data
                    subset_id: currentSubsetId,
                    template_position: currentTemplatePosition,
                    completion_status: 'completed',
                    time_spent_seconds: templateStartTime ? Math.round((Date.now() - templateStartTime) / 1000) : null
                };
                
                // Collect placeholder values
                const inputs = document.querySelectorAll('input[data-placeholder-id]');
                inputs.forEach(input => {
                    const id = input.getAttribute('data-placeholder-id');
                    questionData.values[id] = input.value.trim();
                });
                
                
                // Validate user identification
                if (!currentUserId || !deviceFingerprint) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'Error: User identification not complete. Please refresh the page.';
                    statusDiv.style.display = 'block';
                    return;
                }
                
                // Make sure all required fields are present
                const requiredFields = [
                    'generated_question', 
                    'generated_option1', 
                    'generated_option2',
                    'generated_option3',
                    'generated_option4',
                    'translated_question',
                    'translated_option1',
                    'translated_option2',
                    'translated_option3',
                    'translated_option4'
                ];
                
                let missingFields = [];
                requiredFields.forEach(field => {
                    if (!questionData[field] || questionData[field].trim() === '') {
                        missingFields.push(field);
                    }
                });
                
                if (missingFields.length > 0) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = `Error: Missing required fields: ${missingFields.join(', ')}`;
                    statusDiv.style.display = 'block';
                    return;
                }
                
                // Save to Supabase
                saveToSupabase(questionData);
            }
            
            // Reset the current template
            function resetTemplate() {
                if (currentTemplate) {
                    // Clear any saved progress for this template before reloading
                    const progressKey = `template_progress_${currentUserId}`;
                    localStorage.removeItem(progressKey);
                    
                    // Hide and clear preview panel
                    previewDiv.style.display = 'none';
                    previewDiv.innerHTML = ''; // Clear the preview content
                    
                    // Now reload the template (which will be clean)
                    loadTemplate(currentTemplate);
                } else {
                    fetchRandomTemplate();
                }
            }
            
            // Show skip reason modal
            function showSkipModal() {
                const modal = document.getElementById('skipModal');
                const input = document.getElementById('skipReasonInput');
                const confirmBtn = document.getElementById('skipConfirmBtn');
                
                
                // Reset modal
                input.value = '';
                confirmBtn.disabled = true;
                
                // Show modal
                modal.style.display = 'block';
                
                // Focus on input
                setTimeout(() => input.focus(), 100);
            }
            
            // Hide skip reason modal
            function hideSkipModal() {
                const modal = document.getElementById('skipModal');
                modal.style.display = 'none';
            }
            
            // Skip current template with reason
            async function skipTemplateWithReason(reason) {
                try {
                    // Log the skipped template for analytics
                    if (currentTemplate) {
                        // Send skip data to server for analytics
                        const demographics = window.userDemographics || getPilotUserDemographics(currentUserId);
                        const skipData = {
                            template_id: currentTemplate.id,
                            reasoning_category: currentTemplate.reasoning_category,
                            cultural_aspect: currentTemplate.cultural_aspect,
                            original_template: currentTemplate.template,
                            user_id: currentUserId,
                            device_fingerprint: deviceFingerprint,
                            skip_reason: reason,
                            
                            // Add demographics data
                            language: demographics.language,
                            country: demographics.country,
                            
                            // NEW: Add subset tracking and timing data
                            subset_id: currentSubsetId,
                            template_position: currentTemplatePosition,
                            completion_status: 'skipped',
                            time_spent_seconds: templateStartTime ? Math.round((Date.now() - templateStartTime) / 1000) : null
                        };
                        
                        try {
                            const response = await fetch('/api/templates/skip', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(skipData)
                            });
                            
                            if (response.ok) {
                                markTemplateCompleted(currentTemplate.id); // Mark template as completed in localStorage
                            } else {
                            }
                        } catch (logError) {
                            // Don't block the skip functionality if logging fails
                        }
                    }
                    
                    // Hide modal
                    hideSkipModal();
                    
                    // Clear stored template since skip was successful
                    clearStoredTemplate();
                    
                    // Show loading state
                    loadingDiv.style.display = 'block';
                    templateContainer.style.display = 'none';
                    statusDiv.className = 'status';
                    statusDiv.textContent = 'Loading a new template...';
                    statusDiv.style.display = 'block';
                    
                    // Reset progress to step 1
                    updateProgressSteps(1);
                    
                    // Handle next template based on mode
                    if (currentSubset) {
                        // Subset mode: move to next template in subset
                        if (moveToNextTemplate()) {
                            loadCurrentSubsetTemplate();
                        } else {
                            // All templates in subset completed
                            showCompletionMessage();
                        }
                    } else {
                        // Legacy random mode
                        fetchRandomTemplate();
                    }
                    
                } catch (error) {
                    // Still proceed with skip even if there's an error
                    hideSkipModal();
                    clearStoredTemplate(); // Clear template even on error to avoid being stuck
                    loadingDiv.style.display = 'block';
                    templateContainer.style.display = 'none';
                    statusDiv.className = 'status';
                    statusDiv.textContent = 'Loading a new template...';
                    statusDiv.style.display = 'block';
                    updateProgressSteps(1);
                    
                    // Handle next template based on mode (error case)
                    if (currentSubset) {
                        if (moveToNextTemplate()) {
                            loadCurrentSubsetTemplate();
                        } else {
                            showCompletionMessage();
                        }
                    } else {
                        fetchRandomTemplate();
                    }
                }
            }
            
            // Function to save data to Supabase via our server API
            async function saveToSupabase(questionData) {
                try {
                    statusDiv.className = 'status';
                    statusDiv.textContent = 'Submitting...';
                    statusDiv.style.display = 'block';
                    
                    
                    // Send to our server API (not directly to Supabase)
                    const response = await fetch('/api/annotations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(questionData)
                    });
                    
                    const result = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(result.error || 'Failed to submit');
                    }
                    
                    // Hide preview panel
                    previewDiv.style.display = 'none';
                    
                    // Clear stored template since submission was successful
                    clearStoredTemplate();
                    
                    // NEW: Mark template as completed in localStorage
                    markTemplateCompleted(currentTemplate.id);
                    
                    // Show success message
                    statusDiv.className = 'status success';
                    statusDiv.textContent = 'Annotation submitted successfully!';
                    
                    // Handle next template based on mode
                    setTimeout(() => {
                        if (currentSubset) {
                            // Subset mode: move to next template in subset
                            if (moveToNextTemplate()) {
                                loadCurrentSubsetTemplate();
                            } else {
                                // All templates in subset completed
                                showCompletionMessage();
                            }
                        } else {
                            // Legacy random mode
                            fetchRandomTemplate();
                        }
                    }, 2000);
                    
                } catch (error) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'Error: ' + error.message;
                    statusDiv.style.display = 'block';
                }
            }
            
            // Setup modal event listeners
            function setupModalEventListeners() {
                const skipModal = document.getElementById('skipModal');
                const skipReasonInput = document.getElementById('skipReasonInput');
                const skipCancelBtn = document.getElementById('skipCancelBtn');
                const skipConfirmBtn = document.getElementById('skipConfirmBtn');
                
                // Enable/disable confirm button based on input
                skipReasonInput.addEventListener('input', function() {
                    const hasText = this.value.trim().length > 0;
                    skipConfirmBtn.disabled = !hasText;
                });
                
                // Cancel button
                skipCancelBtn.addEventListener('click', hideSkipModal);
                
                // Confirm button
                skipConfirmBtn.addEventListener('click', function() {
                    const reason = skipReasonInput.value.trim();
                    if (reason) {
                        skipTemplateWithReason(reason);
                    }
                });
                
                // Close modal when clicking outside
                skipModal.addEventListener('click', function(e) {
                    if (e.target === skipModal) {
                        hideSkipModal();
                    }
                });
                
                // Close modal on Escape key
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && skipModal.style.display === 'block') {
                        hideSkipModal();
                    }
                });
            }
            
            // Initialize the app
            setupModalEventListeners();
            init();
        });
    </script>

    <!-- Skip Reason Modal -->
    <div id="skipModal" class="skip-modal">
        <div class="skip-modal-content">
            <h3>‚ö†Ô∏è Why is this template not applicable?</h3>
            <p>Please provide a brief explanation of why this template is not relevant to your cultural context:</p>
            <textarea 
                id="skipReasonInput" 
                class="skip-reason-input" 
                placeholder="Example: This scenario is not common in my culture, or the context doesn't apply to my cultural background..."
                maxlength="500"
            ></textarea>
            <div class="skip-modal-buttons">
                <button id="skipCancelBtn" class="skip-modal-btn skip-cancel-btn">Cancel</button>
                <button id="skipConfirmBtn" class="skip-modal-btn skip-confirm-btn" disabled>Skip Template</button>
            </div>
        </div>
    </div>

</body>
</html>
